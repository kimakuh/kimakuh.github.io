{"pages":[],"posts":[{"title":"[javascript & jquery] - chapter01 변수_part01","text":"Lesson01 변수소개변수란?변수는 물건을 보관했다가 필요할 때 다시 꺼내 사용하는 일종의 창고. 변수는 데이터를 저장하는 장소 변수는 데이터를 읽고 쓰고 할 수 있는 장소 변수를 만들면 데이터를 저장할 빈 영역이 생긴다.(RAM) 변수의 사용 특정 사이트의 로그인 상태 유무를 변수에 저장 사용자가 선택한 메뉴 항목 역시 처음엔 배열 변수에 저장된 내용 슈팅게임에서 현재 기록중인 게임 점수도 변수에 저장 슈팀게임에서 현재 남아있는 캐릭터의 에너지 역시 변수에 저장 쇼핑몰 장바구니에 담겨 있는 상품목록 역시 변수에 저장 화면 가득 출력된 게시물 목록도 배열변수에 저장 Lesson02 변수 만들기변수 하나 만들기1문법 var 변수이름 = 값; 변수를 만드는 가장 일반적인 방법 “자바스크립트 엔진에게 변수를 하나 만든 후 여기에 값을 저장해주세요” ==&gt; 정리하자면 변수는 “=” 연산자를 기준으로 var에 의해서 “변수이름”으로 변수가 만들어지고 이후에 우측에 있는 데이터가 변수에 저장(대입) 된다. var의 정체 var는 변수 선언을 의미하는 키워드. 자바스크립트 엔진은 소스를 해석하는 도중 var라는 키워드를 만나면 “여기는 변수를 만들라는 말이군~” 으로 해석해 변수를 만든다. ;(세미콜론)의 의미 문장 맨 뒤에 붙이는 세미콜론은 문장의 끝을 의미 자바스크립트 엔진은 소스를 해석하는 도중 세미콜론을 만나면 “여기가 하나의 문장(구문)이 끝나는 곳이군!” 으로 해석해 다음 줄로 이동해 다른 코드를 해석한다. 나이가 담긴 변수 age 만들기12345var age = 30; // 컴퓨터 메모리(RAM) 영역에 변수를 만들면 // 자바스크립트가 메모리상에 \"age\" 라는 이름의 // 창고를 만들어 데이터(30)을 보관한다. // 이렇게 보관했다가 나중에 필요할 때마다 꺼내 사용하거나 // 다른 값으로 변경한다. 변수 여러 개 만들기변수를 여러개 만드는 방법은 두 가지가 있다. 방법1 var를 이용해서 여러 줄로 변수 구분을 하는 경우12var 변수이름1 = 데이터;var 변수이름2 = 데이터; 이름과 나이가 담긴 변수 만들기12var name = \"내이름\";var age = 30; 방법2 콤마(,)를 이용해서 변수 구분을 하는 경우1var 변수이름1 = 데이터, 변수이름2 = 데이터; 이름과 나이가 담긴 변수 만들기(콤마를 이용해서)1var name = \"내이름\", age = 30; 두 방법 중 취향에 맞게 사용하면 된다. 변수이름 만들 때 주의사항 숫자로 시작하면 안된다. 대소문자 구분 변수는 대문자가 아닌 소문자로 시작 변하지 않는 환경 변수의 값을 담는 상수 변수는 모두 대문자로 만든다. 여러 단어가 조합되는 경우 낙타 표기법으로 작성 자바스크립트에서 이미 정의된 예약어(키워드) 사용금지 Lesson03 변수에 저장할 수 있는 데이터 종류데이터 위치123var 변수이름 = 데이터; // 일반적으로 \"=\" 기준으로 // 저장소로 사용할 변수이름은 좌측, // 저장할 데이터는 우측에 온다. 데이터의 위치는 일반적으로 “=”를 기준으로 우측에 변수(저장소)는 좌측에 온다. 데이터 종류 데이터형 범위 예 추가설명 숫자형(Number) ±5.0 x 10-324±1.7 x 10308 var age = 30; 초보자용(이해 필수) 문자형(String) “문자열” var name = “내이름”; 초보자용(이해 필수) 논리형(boolean) true(참), false(거짓) var isLogin = false; 초보자용(이해 필수) 특수형(undefined) 변수는 선언했지만 값이 아직 할당되지 않은 상태 var username; 초보자용(이해 필수) 특수값(null) 값이 아직 없다는 의미, 일반적으로 undefined와 같은 의미로 사용 var myClass = null; 초보자용(이해 필수) 함수(Function) function showMenu(){} var func = showMenu; 초중급자용 클래스(Function) function showMenu(){} var myClass = myClass; 초중급자용 객체(Object) function myClass(){} var myClass = new myClass(); 초중급자용 숫자형(Number)1var score = 100; 숫자형은 크게 정수형과 실수형으로 나뉜다. 자료형 내용 예 정수형 10진수 일상 생활에서 사용하는 숫자이며 소수점이 없음 var age = 30; 정수형 16진수 0x로 시작하며 숫자 0~9와 문자 A~F를 사용해서 모든 숫자를 표헌함. 주로 색상 값을 나타낼 때 사용함 var color = 0xF00; // 빨간색 실수형 소수점을 갖는 숫자 var weight = 60.6; // 몸무게 나이, 몸무게와 같은 숫자 정보를 저장할 때 숫자형 사용 게임에서 현재 기록중인 게임 점수를 저장할 때 숫자형 변수 사용 게임에서 현재 남아있는 에너지를 저장할 때 숫자형 변수 사용 홈페이지 메뉴에서 현재 선택된 메뉴 인덱스 값을 저장할 때 숫자형 사용 나이와 몸무게를 각각 age, weight 변수에 담기12var age = 30;var weight = 61.5; 문자형(String)1var userName = \"핸드크림\"; 홈페이지의 메뉴 항목과 같은 글자 정보를 저장할 때 문자형 변수 사용 홈페이지에 로그인할 때 사용하는 아이디와 패스워드 또한 문자형 변수에 담아 사용 게시판의 게시물 제목, 날짜, 글쓴이 본문 등 모두 문자형 변수에 담아 사용 이름, 닉네임, 주소 정보를 담을 때도 문자형 변수 사용 아이디를 id라는 변수에 저장1var id = \"kimakuh\"; 나이를 age라는 변수에 문자열로 저장1var age = \"30\"; 논리형(Boolean)논리형에는 참(true,1)과 거짓(false,0) 두 가지 값이 존재 True(참) 의미 내용 False(참) 의미 내용 맞음 틀림 1 0 같음 다름(같지 않음) 진실 거짓 로그인 했음 로그인 안 했음 현재 로그인 상태 여부를 저장할 때 논리형 변수를 사용 체크박스 선택여부를 저장할 때 논리형 변수를 사용 현재 날씨정보를 cold 변수에 담아 저장1var cold = false; 로그인 유무를 login 변수에 담아 저장1var login = true; undefined변수 undefined가 저장되어 있다면 일반적으로 변수를 만든 후 초기화 하지 않은 상태를 의미 변수를 선언하고 그 변수에 값을 대입하지 않은 경우1234var data1; // 변수를 선언한 후 아무런 값을 넣지 않은 경우 // 변수에는 undefined라는 값이 기본적으로 저장alert(\"data1 =\" + data1); // alert()는 알림창을 출력해주는 기능으로 //변수에 들어있는 내용을 확인 할 수 있다. 함수 인자 값 없이 함수를 호출하는 경우123456function myFunc(data1)&#123; alert(\"data1=\"+ data1);&#125;myFunc(\"value1\"); // data1=\"data\"를 넣은 것과 일치myFunc(); // data1 = undefined를 넣은 것과 일치 존재하지 않는 객체의 프로퍼티에 접근하는 경우1234567function MyClass()&#123; this.name=\"namename\";&#125;var test1 = new MyClass();alert(\"test1.name=\" + test1.name);alert(\"test1.userName=\" + test1.userName); nullnull의 뜻은 아무것도 참조하고 있지 않다.주로 객체를 담을 변수를 초기화할 때 많이 사용 null 값으로 데이터를 초기화하는 경우1234567891011121314151617// 숫자 변수 초기화var data1 = 0;// 문자 변수 초기화var data2 = \"\";// 논리형 변수 초기화var data3 = false;// 객체 변수 초기화var data4 = null;// 일반적으로 초기화와 동시에 변수를 만들게 되는데// 이때 초깃값을 보면 앞으로 이 변수가 어떤 데이터형을// 저장할 변수인지 알 수 있다. undefined 와 nullundefined는 변수의 기본 초깃값이며 null은 객체를 담을 변수를 초기화할 때 사용하는 값 변수에는 숫자, 문자뿐만 아니라 함수, 클래스, 클래스의 인스턴스도 저장 가능하다.","link":"/2018/05/28/chapter01-변수/"},{"title":"github-page-and-hexo","text":"","link":"/2018/04/07/github-page-and-hexo-1/"},{"title":"github-page-and-hexo","text":"","link":"/2018/04/07/github-page-and-hexo/"},{"title":"github-page-and-hexo2","text":"","link":"/2018/04/07/github-page-and-hexo2/"},{"title":"[java] Byte Stream","text":"자바의 입출력 Byte Stream - 바이트 단위로 출력하기1234567891011121314151617public static void main(String[] args) throws Exception &#123; // 1) 파일로 데이터를 출력하는 객체를 준비한다. FileOutputStream out = new FileOutputStream(\"temp/test1.data\"); // 2) 1바이트를 출력한다. // =&gt; int 값을 아규먼트로 넘기더라도 맨 마지막 1바이트만 출력한다. out.write(0x7a6b5c4d); // 출력하는 값은 0x4d 이다. // 3) 출력 도구를 닫는다. // =&gt; 항상 입출력 도구를 사용한 후 닫아야 한다. // =&gt; 어떤 입출력 도구는 닫지 않으면 버퍼(임시메모리)에 남아있는 데이터가 // 출력되지 않고 버려진다. out.close(); System.out.println(\"데이터 출력 완료!\"); &#125; Byte Stream - 바이트 단위로 읽기1234567891011121314public static void main(String[] args) throws Exception &#123; // 1) 파일의 데이터를 읽을 객체를 준비한다. FileInputStream in = new FileInputStream(\"temp/test1.data\"); // 2) 1바이트를 읽는다. // =&gt; read() 메서드의 리턴 타입이 int 라 하더라도 1바이트를 읽어 리턴한다. int b = in.read(); // 읽은 값은 0x4d 이다. // 3) 읽기 도구를 닫는다. in.close(); System.out.printf(\"%x\\n\", b);&#125; Byte Stream - 바이트 배열 출력하기123456789101112public static void main(String[] args) throws Exception &#123; FileOutputStream out = new FileOutputStream(\"temp/test1.data\"); byte[] bytes = new byte[] &#123;0x7a, 0x6b, 0x5c, 0x4d, 0x3e, 0x2f, 0x30&#125;; out.write(bytes); // 바이트 배열 전체를 출력한다. out.close(); System.out.println(\"데이터 출력 완료!\");&#125; Byte Stream - 바이트 배열 읽기12345678910111213141516171819202122public static void main(String[] args) throws Exception &#123; FileInputStream in = new FileInputStream(\"temp/test1.data\"); // 바이트들을 저장할 배열을 준비한다. // =&gt; 이렇게 임시 데이터를 저장하기 위해 만든 바이트 배열을 보통 \"버퍼(buffer)\"라 한다. byte[] buf = new byte[100]; // read(버퍼의주소) // =&gt; 버퍼가 꽉 찰 때까지 읽는다. // =&gt; 물론 버퍼 크기보다 파일의 데이터가 적으면 파일을 모두 읽어 버퍼에 저장한다. // =&gt; 리턴 값은 읽은 바이트의 개수이다. int count = in.read(buf); in.close(); System.out.printf(\"%d\\n\", count); for (int i = 0; i &lt; count; i++) System.out.printf(\"%x \", buf[i]); System.out.println();&#125; Byte Stream - 바이트 배열의 특정 부분을 출력하기123456789101112public static void main(String[] args) throws Exception &#123; FileOutputStream out = new FileOutputStream(\"temp/test1.data\"); byte[] bytes = new byte[] &#123;0x7a, 0x6b, 0x5c, 0x4d, 0x3e, 0x2f, 0x30&#125;; out.write(bytes, 2, 3); // 2번 데이터부터 3 바이트를 출력한다. out.close(); System.out.println(\"데이터 출력 완료!\");&#125; Byte Stream - 읽은 데이터를 바이트 배열의 특정 위치에 저장하기123456789101112131415161718public static void main(String[] args) throws Exception &#123; FileInputStream in = new FileInputStream(\"temp/test1.data\"); byte[] buf = new byte[100]; // read(버퍼의주소, 저장할위치, 읽을바이트개수) // =&gt; 리턴 값은 실제 읽은 바이트의 개수이다. int count = in.read(buf, 10, 40); // 40바이트를 읽어 10번 방부터 저장한다. in.close(); System.out.printf(\"%d\\n\", count); for (int i = 10; i &lt; (count + 10); i++) System.out.printf(\"%x \", buf[i]); System.out.println();&#125;","link":"/2018/04/11/java-Byte-Stream/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/10/23/hello-world/"},{"title":"[java] Character Stream","text":"자바의 입출력 Character Stream - 문자 단위로 출력하기123456789101112131415161718192021222324public static void main(String[] args) throws Exception &#123; // 1) 문자 단위로 출력할 도구 준비 FileWriter out = new FileWriter(\"temp/test2.txt\"); // 2) 문자 출력하기 // =&gt; 자바는 문자 데이터를 다룰 때 UTF-16(2바이트) 유니코드를 사용한다. // =&gt; 그래서 출력할 때 UTF-16 2바이트 유니코드값을 // JVM에 설정된 기본 문자코드표의 값으로 변환하여 출력한다. // =&gt; JVM을 실행할 때 출력 데이터의 문자 코드표를 지정하지 않으면 // OS의 기본 문자코드표에 따라 변환한다. // 예) Windows OS(MS949), Unix(UTF-8) // =&gt; JVM을 실행할 때 출력 데이터의 문자 코드표를 지정하는 방법 // &gt; java -Dfile.encoding=문자코드표 -cp 클래스경로 클래스명 // // =&gt; 따라서 다음 4바이트 값을 출력하면 // 앞의 2바이트는 버리고, 뒤의 2바이트(UTF-16)를 UTF-8 코드표에 따라 // 1 ~ 4 바이트 값으로 변환하여 출력한다. out.write(0x7a6bac00); out.close(); System.out.println(\"출력 완료!\"); &#125; Character Stream - 문자 단위로 읽기1234567891011121314151617181920212223242526272829public static void main(String[] args) throws Exception &#123; // 1) 파일의 데이터를 읽을 객체를 준비한다. FileReader in = new FileReader(\"temp/test2.txt\"); // 2) JVM에 설정된 문자코드표에 따라 바이트를 읽어서 UTF-16으로 바꾼 후에 리턴한다. // =&gt; 리턴 값은 2바이트 UTF-16의 코드 값이다. // =&gt; JVM에 설정된 문자코드표가 UTF-8이면 1 ~ 4 바이트까지 // 문자에 따라 가변적으로 읽어들이다. // 즉 영어 문자는 1바이트를 읽어 2바이트 UTF-16 코드 값으로 바꿀 것이다. // 한글 문자는 3바이트를 읽어 2바이트 UTF-16 코드 값으로 바꿀 것이다. // 문자에 따라 읽는 바이트의 개수가 다르다는 것이다. // =&gt; 이것이 FileInputStream의 read() 메서드와 다른 점이다. // FileInputStream의 read()는 무조건 1바이트를 읽는다. // 그리고 값을 변환하지 않는다. // =&gt; FileReader의 read()는 문자에 따라 1 바이트에서 4 바이트까지 // 읽는 바이트 수가 다른다. // 리턴 값도 읽을 값을 그대로 리턴하는 것이 아니라 UTF-16 코드 값으로 변경하여 // 리턴한다. // 왜? JVM에서 문자를 UTF-16 코드 값으로 다루기 때문이다. // =&gt; 그래서 이미지 파일이나 동영상 파일과 같이 바이너리 데이터는 /// FileReader를 사용하여 읽어서는 안된다. // 왜? 문자라고 간주하고 값을 변경하기 때문이다. int ch = in.read(); // 3) 읽기 도구를 닫는다. in.close(); System.out.printf(\"%x\\n\", ch);&#125; Character Stream - 문자 배열 출력하기12345678910111213141516public static void main(String[] args) throws Exception &#123; FileWriter out = new FileWriter(\"temp/test2.txt\"); char[] chars = new char[] &#123;'A','B','C','가','각','간','똘','똥'&#125;; out.write(chars); // 문자 배열 전체를 출력한다. // 당연히 UTF-16을 JVM 기본 문자 코드표에 따라 변환하여 출력한다. // JVM이 입출력 문자 코드표로 UTF-8을 사용한다면 // 영어는 1바이트로 변환되어 출력될 것이고, // 한글은 3바이트로 변환되어 출력될 것이다. out.close(); System.out.println(\"데이터 출력 완료!\");&#125; Character Stream - 문자 배열 읽기123456789101112131415161718192021222324252627public static void main(String[] args) throws Exception &#123; FileReader in = new FileReader(\"temp/test2.txt\"); // UTF-16 문자 코드 값을 저장할 배열을 준비한다. // =&gt; 이렇게 임시 데이터를 저장하기 위해 만든 바이트 배열을 보통 \"버퍼(buffer)\"라 한다. char[] buf = new char[100]; // read(버퍼의주소) // =&gt; 버퍼가 꽉 찰 때까지 읽는다. // =&gt; 물론 버퍼 크기보다 파일의 데이터가 적으면 파일을 모두 읽어 버퍼에 저장한다. // =&gt; 리턴 값은 읽은 바이트의 개수이다. // =&gt; 파일을 읽을 때 JVM의 문자코드표에 따라 바이트를 읽는다. // 그리고 2바이트 UTF-16 코드 값으로 변환하여 리턴한다. // =&gt; JVM의 문자코드표가 UTF-8이라면, // 파일을 읽을 때, 영어나 숫자, 특수기호는 1바이트를 읽어 UTF-16으로 변환할 것이고 // 한글은 3바이트를 읽어 UTF-16으로 변환할 것이다. int count = in.read(buf); in.close(); System.out.printf(\"%d\\n\", count); for (int i = 0; i &lt; count; i++) System.out.printf(\"%c(%x) \", buf[i], (int)buf[i]); System.out.println();&#125; Character Stream - 문자 배열의 특정 부분을 출력하기123456789101112public static void main(String[] args) throws Exception &#123; FileWriter out = new FileWriter(\"temp/test2.txt\"); char[] chars = new char[] &#123;'A','B','C','가','각','간','똘','똥'&#125;; out.write(chars, 2, 3); // 2번 문자부터 3 개의 문자를 출력한다. out.close(); System.out.println(\"데이터 출력 완료!\");&#125; Character Stream - 읽은 데이터를 문자 배열의 특정 위치에 저장하기123456789101112131415161718public static void main(String[] args) throws Exception &#123; FileReader in = new FileReader(\"temp/test2.txt\"); char[] buf = new char[100]; // read(버퍼의주소, 저장할위치, 읽을바이트개수) // =&gt; 리턴 값은 실제 읽은 문자의 개수이다. int count = in.read(buf, 10, 40); // 40개의 문자를 읽어 10번 방부터 저장한다. in.close(); System.out.printf(\"%d\\n\", count); for (int i = 10; i &lt; (count + 10); i++) System.out.printf(\"%c(%x) \", buf[i], (int)buf[i]); System.out.println();&#125;","link":"/2018/04/11/java-Character-Stream/"},{"title":"[java]기초 - final","text":"Final 의 쓰임 자바에서 절대 변하지 않는 특정한 것을 정하고 싶을 때는 Final을 사용이 키워드는 변수, 메소드, 클래스에 모두 사용할 수 있다.변수에 사용할 경우 변하지 않는 상수메소드가 사용할 때는 재정의가 불가능한 메소드클래스에서 사용할 때는 상속이 불가능한 하나의 완전한 클래스 값이 바뀌는 것을 막는다.한번 정의되면 다시 바뀌지 않는 메소드 최종적으로 규정한다 혹은 정한다. Final 키워드를 사용한 변수를 다룬다.123456public static void main(String[] args) &#123; final int number = 10; // 상수를 정의한다. //number = 5; // 오류가 발생한다. System.out.println(number);&#125; Final 키워드를 사용한 메소드를 다룬다.Parent.java123456public class Parent &#123; public void show() &#123; System.out.println(\"Hi\"); &#125;&#125; Main.java 1234567891011121314151617public class Main extends Parent &#123; // 함수 재정의 ==&gt; 다시 정의한다. // 자신의 부모클래스에서 존재하는 show()라는 함수는 지워버리고 // 자신의 클래스에서 재정의 된(오버라이딩) 함수를 실행한다. public void show() &#123; System.out.println(\"Hello\"); &#125; public static void main(String[] args) &#123; Main main = new Main(); main.show(); &#125;&#125; 하지만 Parent에 아래와 같이 final을 붙이면 Parent.java 123456public class Parent &#123; public final void show() &#123; System.out.println(\"Hi\"); &#125;&#125; Main 클래스에서 오류가 발생한다. ==&gt; 오버라이딩 불가 ==&gt; 함수의 재정의를 막는다. 1234567891011121314151617public class Main extends Parent &#123; // 함수 재정의 ==&gt; 다시 정의한다. // 자신의 부모클래스에서 존재하는 show()라는 함수는 지워버리고 // 자신의 클래스에서 재정의 된(오버라이딩) 함수를 실행한다. public void show() &#123; System.out.println(\"Hello\"); &#125; public static void main(String[] args) &#123; Main main = new Main(); main.show(); &#125;&#125; Final 키워드를 사용한 클래스를 다룬다.기존에 만들어진 Parent 클래스에 public 대신 final을 붙인다. 12345final class Parent &#123; public final void show() &#123; System.out.println(\"Hi\"); &#125;&#125; 위와 같이 바꿔주면 메인클래스에서 오류가 발생한다. final로 정의된 클래스를 상속 받고자 했기 때문이다. ==&gt; 상속 불가 클래스명에 final이 붙게 된다면 그 클래스는 더 이상 어떠한 클래스에서도 상속이 불가능 하다.","link":"/2018/05/03/java-기초-final/"},{"title":"[java]기초 - 객체지향의 활용","text":"객체지향의 활용문법을 이해한다고해서 프로그램을 작성할 수 있는것은 아니다. 객체지향 기법의 활용 게임 캐릭터 공격 프로젝트 구현Hero.java 123456789101112public class Hero &#123; String name; public Hero(String name) &#123; this.name = name; &#125; public void attack() &#123; System.out.println(\"기본 공격\"); &#125;&#125; Warrior.java 123456789101112public class Warrior extends Hero &#123; public Warrior(String name) &#123; super(name); // 부모클래스의 생성자 &#125; public void WarriorAttack() &#123; System.out.println(\"후려치기\"); &#125;&#125; Archer.java 123456789101112public class Archer extends Hero &#123; public Archer(String name) &#123; super(name); &#125; public void ArcherAttack() &#123; System.out.println(\"활쏘기\"); &#125;&#125; Wizard.java 123456789101112public class Wizard extends Hero&#123; public Wizard(String name) &#123; super(name); &#125; public void WizardAttack() &#123; System.out.println(\"얼리기\"); &#125;&#125; Main.java 1234567891011121314151617181920212223242526public class Main &#123; public static void main(String[] args) &#123; Hero[] heros = new Hero[3]; heros[0] = new Warrior(\"전사\"); heros[1] = new Archer(\"궁수\"); heros[2] = new Wizard(\"마법사\"); for (int i = 0; i &lt; heros.length; i++) &#123; heros[i].attack(); if (heros[i] instanceof Warrior) &#123; Warrior temp = (Warrior) heros[i]; temp.WarriorAttack(); &#125; else if (heros[i] instanceof Archer) &#123; Archer temp = (Archer) heros[i]; temp.ArcherAttack(); &#125; else if (heros[i] instanceof Wizard) &#123; Wizard temp = (Wizard) heros[i]; temp.WizardAttack(); &#125; &#125; &#125;&#125;","link":"/2018/05/04/java-기초-객체지향의-활용/"},{"title":"[java]기초 - 객체(Object)","text":"객체(Object) - 모든 객체의 조상 객체(Object) 클래스는 모든 객체의 조상으로서 쓰인다. 자바에서 사실 모든 클래스는 암시적으로 Object 클래스를 상속 받고 있다. 그런 이유로 Object 클래스는 모든 클래스의 조상이라고 할 수 있다. 이러한 클래스가 존재하는 이유는 모든 클래스가 공통으로 포함하고 있어야 하는 기능을 제공하기 위함이다. 객체(Object) 클래스에 대해서 이해하자 객체를 비교하는 방법을 알아본다.Archer.java 12345678910111213141516171819202122public class Archer &#123; // Archer 가 Object를 상속받는다고 // 명시해 주지 않아도 // 상속받도록 설정되어 있다. // ==&gt; Archer는 항상 Object의 자식클래스이다. String name; String power; public Archer(String name, String power) &#123; this.name = name; this.power = power; &#125; public boolean equals(Object obj) &#123; // 다형성 Archer temp = (Archer) obj; if(name == temp.name &amp;&amp; power == temp.power) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; Main.java 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Archer archer1 = new Archer(\"궁수1\", \"상\"); Archer archer2 = new Archer(\"궁수2\", \"중\"); System.out.println(archer1 == archer2); Archer archer3 = new Archer(\"궁수1\", \"상\"); Archer archer4 = new Archer(\"궁수1\", \"상\"); System.out.println(archer3 == archer4); // 두 개의 인스턴스가 내부적으로 가지고 있는 값이 같더라도 // 인스턴스의 값이 아닌 인스턴스 자체를 비교하기 때문에 // false가 나온다 Archer archer5 = new Archer(\"궁수1\", \"상\"); Archer archer6 = new Archer(\"궁수1\", \"상\"); System.out.println(archer5.equals(archer6)); // 두 인스턴스가 내부적으로 가지는 변수의 값을 비교하기 때문에 // true &#125;&#125;","link":"/2018/05/04/java-기초-객체-Object/"},{"title":"[java]기초 - 기본 입출력(Input & Output)","text":"사용자와 상호작용입력 받은 자료는 내부적으로 어떠한 처리를 한 뒤에 다시 사용자에게 그 값을 반환할 수 있다. 프로그램이 입출력을 지원한다는 것은 사용자 인터페이스가 뛰어나다는 의미 기본입출력 팁 자바에서는 Scanner클래스만 잘 활용해도 다양한 입출력 형태를 구현할 수 있다. 주석은 일단 최대한 많이 작성하는 습관을 들여야 한다. 주석은 컴파일 단계에서 제거되기 때문에 프로그램의 크기와는 상관없다. Scanner로 문자열을 입력받고 싶을 때에는 next() 함수와 nextLine()을 적절히 활용하자. 특정한 정수를 입력받아서 그대로 출력하는 프로그램12345678public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 자바에서 제공하는 라이브러리 // (System.in) 콘솔장에서 입력하는 어떠한 데이터. System.out.print(\"정수를 입력하세요 : \"); int i = scan.nextInt(); // 입력받은 정수를 i에 넣어준다. System.out.println(\"입력된 정수는 \" + i + \"입니다.\"); scan.close();&#125; 파일에 차례로 입력된 모든 정수에 100을 곱해 출력하는 프로그램1234567891011121314public static void main(String[] args) &#123; // 파일을 컨트롤할 수 있는 file변수와 // 그 파일로 부터 직접 파일에 쓰여있는 내용을 읽어올 수 있는 scan 변수를 만든다. File file = new File(\"input.txt\"); // input.txt 파일을 읽어와서 file변수가 그것을 처리할 수 있게 한다. try &#123; // 파일이 없을 경우, 또는 오류상황이 발생했을때를 대비해 예외처리를 한다. Scanner scan = new Scanner(file); // 사용자로부터 입력받는게 아니라 파일을 통해 입력을 받는다. while (scan.hasNextInt()) &#123; // scan이 읽어오고 있는 파일에서 다음으로 읽어올 정수가 있나 확인 System.out.println(scan.nextInt() * 100); // 정수에 100을 곱하여 출력 &#125; scan.close(); &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일을 읽어오는 도중에 오류가 발생했습니다.\"); &#125;&#125; input.txt 12300 30 20 49 39 227 1단부터 9단까지 구구단을 출력하는 프로그램","link":"/2018/04/22/java-기초-기본-입출력-Input-Output/"},{"title":"[java]기초 - 다차원배열","text":"배열의 확장대부분 2차원배열배열이 배열의 원소로 들어가는 구조행과 열의 조합 10 x 10의 정수 랜덤 데이터를 생성하여 전체 데이터를 분석1234567891011121314151617181920public static void main(String[] args) &#123; int N = 50; // 행과 열의 길이 // 2500개의 데이터가 들어간다. // int =&gt; 4byte 라고하면 // 결국 10000byte 가 되고 // 10000byte = 10KB int[][] arr = new int[N][N]; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; arr[i][j] = (int) (Math.random() * 10);// (int) (Math.random() * 10); 0 부터 9까지의 랜덤한 정수가 // 만들어진다. &#125; &#125; for (int i = 0; i&lt;N;i++) &#123; for (int j =0; j&lt;N;j++) &#123; System.out.print(arr[i][j] + \" \"); &#125; System.out.println(); &#125;&#125;","link":"/2018/04/22/java-기초-다차원배열/"},{"title":"[java]기초 - 다형성","text":"자바에서 다형성(Polymorphism)의 쓰임을 알아본다. 다형성(Polymorphism) - 다양한 동작 다형성은 기본적으로 다양한 형태의 성질을 가진다는 의미를 가지고 있다.기본적으로 자바는 다형성을 그 특징으로 가지는 객체 지향 프로그래밍 언어이며,자바에서는 이 다형성을 이용하여 객체를 사용할 때 사용하는 변수 형태를 바꾸어 여러 타입의 객체를 참조할 수 있다. 결과적으로 이러한 다형성의 개념을 적절하게 이용할 때 프로그램의 소스 코드를 유연하게 구성할 수 있습니다. 다형성은 부모 클래스 타입의 참조 변수로 하위 클래스의 객체를 참조할 수 있게 해준다. 과일 정보 프로젝트 구현Fruit.java12345678910111213public class Fruit &#123; String name; int price; int fresh; public void show() &#123; System.out.println(\"이름 : \" + name); System.out.println(\"가격 : \" + price); System.out.println(\"신선도 : \" + price); &#125; &#125; Peach.java1234567public class Peach extends Fruit &#123; public Peach() &#123; price = 1500; name = \"복숭아\"; fresh = 75; &#125;&#125; Banana.java1234567public class Banana extends Fruit &#123; public Banana() &#123; price = 1000; name = \"바나나\"; fresh = 50; &#125;&#125; Main.java1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.print(\"바나나 : 1, 복숭아 : 2 ?\"); int input = scan.nextInt(); Fruit fruit; if (input == 1) &#123; // 부모클래스의 변수로서 // 자신의 자식클래스의 인스턴스를 넣어줄 수 있다. fruit = new Banana(); fruit.show(); &#125; else if (input == 2) &#123; fruit = new Peach(); fruit.show(); &#125; &#125;&#125;","link":"/2018/05/03/java-기초-다형성/"},{"title":"[java]기초 - 반복함수와 재귀함수","text":"반복함수 : 단순히 while 혹은 for 문법을 이용하여 특정한 처리를 반복하는 방식재귀함수 : 자신의 함수 내부에서 자기 자신을 스스로 호출함으로써 재귀적으로 문제를 해결하는 함수 재귀함수는 경우에 따라서는 아주 간결하고 직관적인 코드로 문제를 해결할 수 있게 해주지만 때에 따라서는 심각한 비효율성을 낳을 수 있기 때문에알고리즘을 작성할 때 유의할 필요가 있다. 팩토리얼을 재귀함수로 구현1234567891011121314// 팩토리얼이란?// 5! (5 팩토리얼)// 5! = 5 * 4 * 3 * 2 * 1 = 120public static int factorial(int number) &#123; int sum = 1; for (int i = 2; i &lt;= number; i++) &#123; sum *= i; &#125; return sum;&#125;public static void main(String[] args) &#123; System.out.println(\"10팩토리얼 : \" + factorial(10));&#125; 팩토리얼을 반복함수로 구현123456789101112131415// 팩토리얼이란?// 5! (5 팩토리얼)// 5! = 5 * 4 * 3 * 2 * 1 = 120public static int factorial(int number) &#123; if (number == 1) return 1; else return number * factorial(number - 1); // 5! = 5 * 4! // 4! = 4 * 3!&#125;public static void main(String[] args) &#123; System.out.println(\"10팩토리얼 : \" + factorial(10));&#125; 피보나치 수열을 반복함수로 구현123456789101112131415161718192021222324252627282930// 피보나치수열// 이전 두개의 수를 합쳐서 다음 한개의 수를 만든다.// 1 + 1 = 2// 1 + 2 = 3// 2 + 3 = 5// 3 + 5 = 8// 피보나치수열에서 몇번째 해당하는 것이 어떤 값인가 구하는 프로그램public static int fibonacci(int number) &#123; int one = 1; int two = 1; int result = -1; // 문제가 발생한것 if (number == 1) &#123; return one; &#125; else if (number == 2) &#123; return two; &#125; else &#123; for (int i = 2; i &lt; number; i++) &#123; result = one + two; one = two; two = result; &#125; &#125; return result;&#125;public static void main(String[] args) &#123; System.out.println(\"피보나치 수열의 10번째 원소는 \" + fibonacci(10));&#125; 피보나치 수열을 재귀함수로 구현123456789101112131415161718192021222324252627// 피보나치수열// 이전 두개의 수를 합쳐서 다음 한개의 수를 만든다.// 1 + 1 = 2// 1 + 2 = 3// 2 + 3 = 5// 3 + 5 = 8// 피보나치수열에서 몇번째 해당하는 것이 어떤 값인가 구하는 프로그램public static int fibonacci(int number) &#123; if (number == 1) &#123; return 1; &#125; else if (number == 2) &#123; return 1; &#125; else &#123; return fibonacci(number - 1) + fibonacci(number - 2); &#125;&#125;public static void main(String[] args) &#123; System.out.println(\"피보나치 수열의 10번째 원소는 \" + fibonacci(10));&#125;// 작은 값에서는 활용할 수 있으나, 값이 커질수록 컴퓨터 연산이 비효율적이다.// 예) 50을 넣으면 값이 나오지 않거나 이상한 값이 나온다.","link":"/2018/04/22/java-기초-반복함수와-재귀함수/"},{"title":"[java]기초 - 배열(Array)","text":"배열은 쉽게 말해 데이터가 많을 때 사용하는 것간단한 프로그램 예제에서는 단순히 한 두개의 변수만으로 프로그램을 작동시킬 수 있었지만현실에서의 다양한 프로그램에는 아주 많은 양의 데이터가 사용되는 것이 일반적이다.따라서 데이터가 많을 때 주로 배열을 이용할 수 있다.이 때 배열은 한없이 많을 수 있으면서도 그 데이터 개수가 변경될 수 있는 데이터들의 집합을지정해 줄 수 있기 때문에 효과적으로 대부분의 프로그램에서 사용된다. 데이터가 들어갈 공간을 만들어준다. 원하는 개수만큼 배열 생성 및 최댓값을 구하는 프로그램1234567891011121314151617181920public static int max(int a, int b) &#123; return (a &gt; b) ? a : b; // a가 b보다 클때는 a를 반환하고 // 그렇지 않을 때는 b를 반환&#125;public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.print(\"생성한 배열의 크기 입력 : \"); int number = scan.nextInt(); int[] arr = new int[number]; for (int i = 0; i &lt; number; i++) &#123; System.out.print(\"배열에 입력할 정수를 하나씩 입력하세요(양수) : \"); arr[i] = scan.nextInt(); &#125; int result = -1; for (int i = 0; i &lt; number; i++) &#123; result = max(result, arr[i]); &#125; System.out.println(\"입력한 정수 중 가장 큰 값은 \" + result);&#125; 100개의 랜덤 정수의 평균을 구하는 프로그램1234567891011public static void main(String[] args) &#123; int[] arr = new int[100]; for (int i = 0; i &lt; 100; i++) &#123; arr[i] = (int) (Math.random() * 100 + 1); &#125; int sum = 0; for (int i = 0; i &lt; 100; i++) &#123; sum += arr[i]; &#125; System.out.println(\"100 개의 랜덤 정수의 평균 값은 \" + sum / 100);&#125;","link":"/2018/04/22/java-기초-배열-Array/"},{"title":"[java]기초 - 사용자 정의 함수","text":"자바는 객체지향의 꽃 객체지향 : 객체는 일반적으로 말하는 물건을 의미하며, 여기서 물건은 단순한 데이터가 아니고 그 데이터의 조작 방법에 대한 정보 또한 포함하고 있어 그것을 대상으로 다루는 방법을 객체지향이라고 한다. 사용자 정의 함수사용자 정의 함수는 정해진 특정한 기능을 수행하는 모듈을 의미 ==&gt; 함수를 적절히 활용하면 하나의 문제를 작게 분해할 수 있다.예를 들어, 이진 탐색 트리는 삽입, 삭제, 순회 등 다양한 함수의 집합으로 구성된다.만약 사용자 정의 함수가 없다면 오직 메인 함수에서 모든 알고리즘을 처리해야 하는데 이는 작업의 효율성을 저하시킬 수 있다. 또한 함수는 각각의 모듈로서 쉽게 수정되고 보완될 수 있다는 장점이 있다. 3개의 수 최대 공약수를 찾는 프로그램123456789101112131415161718192021222324252627282930313233// 함수// 함수의 반환형 ==&gt; int// 함수의 이름 ==&gt; function// 매개변수 ==&gt; int a, int b, int c ==&gt; 일반적으로 함수가 어떠한 값을 처리할때 사전에 주어진 값// 사용자 정의 함수// 자바에서는 메서드랑 함수랑 같은의미.// 반환형, 함수명, 매개뱐스public static int function(int a, int b, int c) &#123; int min; // 가장 작은 수 if (a &gt; b) &#123; if (b &gt; c) &#123; min = c; &#125; else &#123; min = b; &#125; &#125; else &#123; if (a &gt; c) &#123; min = c; &#125; else &#123; min = a; &#125; &#125; for (int i = min; i &gt; 0; i--) &#123; if (a % i == 0 &amp;&amp; b % i == 0 &amp;&amp; c % i == 0) &#123; return i; &#125; &#125; return -1;&#125;public static void main(String[] args) &#123; System.out.println(\"(400,300,750)의 최대 공약수 = \" + function(400, 300, 750)); // 출력결과 (400,300,750)의 최대 공약수 = 50&#125; 약수 중 K번째로 작은 수를 찾는 프로그램123456789101112131415161718192021public static int function(int number, int k) &#123; for (int i = 1; i &lt;= number; i++) &#123; if (number % i == 0) &#123; k--; if (k == 0) &#123; return i; &#125; &#125; &#125; return -1;&#125;public static void main(String[] args) &#123; int result = function(3050, 10); // 3050의 10번째 약수를 찾겠다. if (result == -1) &#123; System.out.println(\"3050의 10번째 약수는 없습니다.\"); &#125; else &#123; System.out.println(\"3050의 10번째 약수는 \" + result); &#125;&#125; 문자열에서 마지막 단어를 반환하는 함수123456789101112131415161718192021public static char function(String input) &#123; return input.charAt(input.length() - 1); // String은 문자열을 의미하는 자료형으로 // 내부적으로 클래스로 작성이 되어있다. // 때문에 charAt과 같은 다양한 함수를 가진다. // charAt은 몇번째 문자열을 뽑아오는 함수 // input이라는 입력값이 들어왔을 때 // input의 길이 즉 문자열의 길이[length()]에서 // -1을 뺀 문자열을 가져온다. // ==&gt; 즉 가장마지막에 위치한 문자열을 가져온다. // input.length() 은 해당 문자열의 길이를 말한다. // 즉 Hello World를 보면 띄어쓰기를 포함해서 // 총 11개의 문자열로 구성되어 있다. // charAt은 0부터 시작하기 때문에 Hello World에서 // 10번째 문자열은 d가 된다. // charAt(10) ==&gt; 'd'&#125;public static void main(String[] args) &#123; System.out.println(\"Hello World의 마지막 단어는 \" + function(\"Hello World\")); // 출력결과 d&#125; max()를 이용하여 최대값을 저장하는 프로그램123456789101112131415161718public static int max(int a, int b) &#123; return (a &gt; b) ? a : b; // 삼항연산자 // a가 b보다 크다면 a를 반환하고 // 그렇지 않다면 b를 반환한다.&#125;public static int function(int a, int b, int c) &#123; int result = max(a, b); // a와 b중에서 더 큰값을 result에 넣는다. result = max(result, c); // result의 값을 다시 c와 비교 return result; // 결과적으로 가장 큰 값이 result에 담기게된다.&#125;// 함수를 여러개 만들어서 모듈화를 한다.public static void main(String[] args) &#123; System.out.println(\"(345,567,783) 중에 가장 큰 값은 \" + function(345, 567, 7830));&#125;","link":"/2018/04/22/java-기초-사용자-정의-함수/"},{"title":"[java]기초 - 배운내용정리하기(과제)","text":"이름을 출력하는 프로그램작성123456public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.print(\"이름을 입력해 주세요 &gt; \"); String name = scan.nextLine(); System.out.println(name);&#125; 사각형 모양을 출력하는 프로그램12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; // 이중 for문 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(); for (int j = 0; j &lt; 10; j++) &#123; System.out.print(\"*\"); &#125; &#125; System.out.println(); // while 문 System.out.println(\"---------------------------------\"); int line = 0; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(\"6\"); &#125; System.out.println(); line++; if (line == 5) &#123; break; &#125; &#125; // 꼼수... System.out.println(\"---------------------------------\"); for (int count = 0; count &lt; 5; count++) &#123; System.out.print(\"9999999999\"); System.out.println(); &#125;&#125;","link":"/2018/04/22/java-기초-배운내용정리하기-과제/"},{"title":"[java]기초 - 상속","text":"상속 = 클래스 간의 상호작용 상속이란 쉽게 말해서 다른 클래스가 가지고 있는 정보를 자신이 포함하겠다는 의미즉, 다른 클래스에 대한 정보를 상속받아 자신이 그대로 사용할 수 있도록 한다. 하나의 사람을 의미하는 Person 클래스를 생성한다.12345678910111213141516171819202122232425262728293031323334353637383940public class Person &#123; private String name; private int age; private int height; private int weight; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getHeight() &#123; return height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; public Person(String name, int age, int height, int weight) &#123; super(); this.name = name; this.age = age; this.height = height; this.weight = weight; &#125; &#125; Person을 상속받아 하나의 학생을 의미하는 Student 클래스12345678910111213141516171819202122232425262728293031323334353637383940public class Student extends Person&#123; private String studentID; private int garde; private double GPA; public String getStudentID() &#123; return studentID; &#125; public void setStudentID(String studentID) &#123; this.studentID = studentID; &#125; public int getGarde() &#123; return garde; &#125; public void setGarde(int garde) &#123; this.garde = garde; &#125; public double getGPA() &#123; return GPA; &#125; public void setGPA(double gPA) &#123; GPA = gPA; &#125; public Student(String name, int age, int height, int weight, String studentID, int garde, double gPA) &#123; super(name, age, height, weight); this.studentID = studentID; this.garde = garde; GPA = gPA; &#125; public void show() &#123; System.out.println(\"----------------------------\"); System.out.println(\"학생이름 : \" + getName()); System.out.println(\"학생나이 : \" + getAge()); System.out.println(\"학생키 : \" + getHeight()); System.out.println(\"학생몸무게: \" + getWeight()); System.out.println(\"학생 학번 : \" + getStudentID()); System.out.println(\"학생 학년 : \" + getGarde()); System.out.println(\"학생 학점 : \" + getGPA()); &#125;&#125; Student 클래스를 이용하여 객체를 생성123456789public static void main(String[] args) &#123; // TODO Auto-generated method stub Student student1 = new Student(\"초보자\", 20,174,40,\"20180502\", 1, 4.5); Student student2 = new Student(\"신규자\", 20,180,90,\"20180503\", 2, 3.0); student1.show(); student2.show();&#125; Person을 상속받아 하나의 선생님을 의미하는 Teacher 클래스123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Teacher extends Person&#123; private String teacherID; private int monthSalary; private int workedYear; public String getTeacherID() &#123; return teacherID; &#125; public void setTeacherID(String teacherID) &#123; this.teacherID = teacherID; &#125; public int getMonthSalary() &#123; return monthSalary; &#125; public void setMonthSalary(int monthSalary) &#123; this.monthSalary = monthSalary; &#125; public int getWorkedYear() &#123; return workedYear; &#125; public void setWorkedYear(int workedYear) &#123; this.workedYear = workedYear; &#125; public Teacher(String name, int age, int height, int weight, String teacherID, int monthSalary, int workedYear) &#123; super(name, age, height, weight); this.teacherID = teacherID; this.monthSalary = monthSalary; this.workedYear = workedYear; &#125; public void show() &#123; System.out.println(\"----------------------------\"); System.out.println(\"교사이름 : \" + getName()); System.out.println(\"교사나이 : \" + getAge()); System.out.println(\"교사키 : \" + getHeight()); System.out.println(\"교사몸무게: \" + getWeight()); System.out.println(\"교사 직원번호 : \" + getTeacherID()); System.out.println(\"교사 월급 : \" + getMonthSalary()); System.out.println(\"교사 연차 : \" + getWorkedYear()); &#125; &#125; 데이터를 입력받은 데이터를 배열을 이용하여 저장하고 출력하는 연습12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.print(\"총 몇 명의 학생이 존재합니까? \"); int number = scan.nextInt(); Student[] students = new Student[number]; for (int i = 0; i &lt; number; i++) &#123; String name; int age; int height; int weight; String studentID; int garde; double gPA; System.out.println(\"학생의 이름을 입력하세요 : \"); name = scan.next(); System.out.println(\"학생의 나이를 입력하세요 : \"); age = scan.nextInt(); System.out.println(\"학생의 키를 입력하세요 : \"); height = scan.nextInt(); System.out.println(\"학생의 몸무게를 입력하세요 : \"); weight = scan.nextInt(); System.out.println(\"학생의 학번을 입력하세요 : \"); studentID = scan.next(); System.out.println(\"학생의 학년을 입력하세요 : \"); garde = scan.nextInt(); System.out.println(\"학생의 학점을 입력하세요 : \"); gPA = scan.nextDouble(); students[i] = new Student(name, age, height, weight, studentID, garde, gPA); System.out.println(); System.out.println(\"----------------------------------------\"); System.out.println(); &#125; for (int i = 0; i &lt; number; i++) &#123; students[i].show(); &#125; // TODO Auto-generated method stub Student student1 = new Student(\"초보자\", 20, 174, 40, \"20180502\", 1, 4.5); Student student2 = new Student(\"신규자\", 20, 180, 90, \"20180503\", 2, 3.0); student1.show(); student2.show(); Student[] student = new Student[100]; for (int i = 0; i &lt; 100; i++) &#123; student[i] = new Student(\"초보자\", 20, 174, 40, i + \" \", 1, 4.5); student[i].show(); &#125; Teacher teacher1 = new Teacher(\"선생님1\", 20, 174, 40, \"teacher1\", 10000000, 5); Teacher teacher2 = new Teacher(\"선생님2\", 20, 174, 40, \"teacher2\", 20000000, 6); teacher1.show(); teacher2.show(); &#125;&#125;","link":"/2018/05/02/java-기초-상속/"},{"title":"[java]기초 - 추상","text":"자바 객체지향의 활용 자바에서의 객체지향을 본격적으로 활용하기 위해서는 자바의 객체지향 개념을 더욱 더 깊게 이해하고 적용할 필요가 있다.자바에서는 C언어나 다른 원시적 프로그래밍 언어에서는 제공하지 않았던 특수한 기능을 제공한다.대표적으로 추상(Abstract)의 개념이 있으며 그와 비슷하지만 조금 다른 개념인 인터페이스(Interface)의 개념이 존재한다. 자바에서는 이러한 다양한 설계 기법들을 제공하기 때문에 개발 자체에서의 안정성 및 확장 가능성을 보장 받을 수 있다. ※ 객체지향 : 객체는 일반적으로 말하는 물건을 의미하며 여기서 물건은 단순한 데이터가 아니고 그 데이터의 조작 방법에 대한 정보 또한 포함하고 있어 그것을 대상으로 다루는 수법을 객체지향이라고 한다. 추상(Abstract)자바에서는 일종의 미완성 클래스라고 할 수 있는 추상(Abstract) 클래스를 제공합니다. 추상클래스는 직접적으로 객체 인스턴스를 생성할 수 없다. 하지만 새로운 클래스를 작성하는 데 밑바탕이 되는 역할을 해준다는 것에서 의미가 있다.어느 정보 미리 설계로서 틀을 갖추고 클래스를 작성할 수 있게 한다는 기능적인 측면에서 의미가 있다. 추상 클래스를 사용하려면 꼭 상속을 받아야 하며 상속받은 모든 추상 메소드는 반드시 구현을 해주어야 한다. 추상의 개념을 이용하여 음악 플레이어 클래스를 구현합니다.Player.java 123456abstract class Player &#123; abstract void play(String songName); abstract void pause(); abstract void stop();&#125; Main.java 123456789101112131415161718192021222324252627public class Main extends Player &#123; public static void main(String[] args) &#123; Main main = new Main(); main.play(\"싸이 - 강남스타일 \"); main.pause(); main.stop(); &#125; @Override void play(String songName) &#123; System.out.println(songName + \"곡을 재생합니다.\"); &#125; @Override void pause() &#123; System.out.println(\"곡을 일시정지합니다.\"); &#125; @Override void stop() &#123; System.out.println(\"곡을 정지합니다.\"); &#125;&#125; 추상의 개념을 이용하여 동물 클래스를 구현합니다.Animal.java123abstract class Animal &#123; abstract void crying();&#125; Cat.java12345678public class Cat extends Animal&#123; @Override void crying() &#123; System.out.println(\"야옹야옹\"); &#125;&#125; Dog.java12345678public class Dog extends Animal&#123; @Override void crying() &#123; System.out.println(\"멍멍\"); &#125;&#125; Main.java1234567891011public class Main &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); Cat cat = new Cat(); dog.crying(); cat.crying(); &#125;&#125;","link":"/2018/05/02/java-기초-추상/"},{"title":"[java]기초 - 클래스(Class)","text":"클래스는 객체 지향 프로그래밍에 있어서 가장 기본이 되는 것.클래스를 이용하여 현실 게계의 특정한 물건을 지칭할 수 있다.가장 많이 사용되는것이 Node클래스.개발 프로젝트에서는 하나의 처리할 데이터 단위를 명시하는데 사용되기도 한다. 하나의 틀어떤 특징 혹은 속성을 가진 변수를 만들어서 사용할 수 있도록하는것 =&gt; 인스턴스화 =&gt;인스턴스로 만든다. 객체 : 실제 세계의 사물 Node 클래스를 이용하여 두 점 사이의 중점을 구하는 프로그램12345678910111213141516171819202122232425262728293031323334353637383940414243444546Node.javapublic class Node &#123; private int x; private int y; // Node 라는것은 좌표를 의미 // x와 y의 값을 외부에서 바꿀 수 없도록 private 사용 public int getX() &#123; // public을 사용해서 외부에서 getX()에 접근하도록 한다. return x; &#125; public void setX(int x) &#123; // x의 값을 설정하는 함수 this.x = x; // 기존에 가지고있는 x의 값을 현재 매개변수 x 로 값을 변경 &#125; public int getY() &#123; // public을 사용해서 외부에서 getY()에 접근하도록 한다. return y; &#125; public void setY(int y) &#123; // y의 값을 설정하는 함수 this.y = y; // 기존에 가지고있는 y의 값을 현재 매개변수 y 로 값을 변경 &#125; // 생성자 public Node(int x, int y) &#123; // 인스턴스 즉 객채를 하나 만들어줄때 // 자동으로 값들을 초기화 해주는 함수 this.x = x; this.y = y; // Node 라는 인스턴스 변수를 만들어줌과 동시에 // x 와 y 의 값을 초기화 해준다. &#125; public Node getCenter(Node other) &#123; // getCenter는 다른 Node를 매개변수로 받는다. // 즉 다른 Node와 비교해서 // 자신이 가지고있는 x,y 좌표와 다른 Node가 가지고있는 // x,y 좌표를 비교해서 정확히 정중앙을 가지는 // 좌표를 반환한다. return new Node((this.x + other.getX()) / 2, (this.y + other.getY()) / 2); &#125;&#125; 123456789101112Main.java public static void main(String[] args) &#123; Node one = new Node(10, 20); Node two = new Node(30, 40); Node result = one.getCenter(two); System.out.println(\"x는 \" + result.getX()); System.out.println(\"y는 \" + result.getY()); &#125;","link":"/2018/04/22/java-기초-클래스-Class/"},{"title":"[java]기초 - 조건문 & 반복문","text":"논리적 흐름의 기본 조건문 : 조건에 따라 실행하거나 실행하지 않거나. ==&gt; 조건에 따라서 실행여부 결정반복문 : 조건이 맞다면 그 조건 안에서 계속해서 반복한다. 조건문 &amp; 반복문 정리 하나의 비교연산자는 true 혹은 false를 반환하게 됩니다. 모든 조건문 / 반복문에서는 왠만하면 무조건 괄호를 적용해라. for문 혹은 while문은 얼마든지 중첩될 수 있다. for(;;)은 while(ture)와 똑같이 무한 루프라는 의미로 동작한다. break;를 이용하여 반복문을 즉시 빠져나올 수 있다. 12345678910public static void main(String[] args) &#123; int count = 0; for (;;) &#123; System.out.println(\"출력\"); count++; if (count == 10) &#123; break; &#125; &#125; if문을 이용하여 문자열이 특정문자열을 포함하는지 확인하는 프로그램1234567891011121314151617public static void main(String[] args) &#123; String a = \"I LOVE YOU.\"; // 조건문 if(a.contains(\"LOVE\")) &#123; // 문자열을 검사한다. // a에 들어있는 I LOVE YOU. 라는 문자열에 // LOVE가 들어있는지(포함하는지) // 들어있는 경우 실행되는 문장이 들어간다. System.out.println(\"Me Too.\"); &#125; else &#123; // 들어있지 않은 경우 실행되는 부분 System.out.println(\"I Hate You.\"); &#125; &#125; 점수에 따라서 다른 메세지를 출력하는 프로그램123456789101112131415public static void main(String[] args) &#123; int score = 95; if (score &gt;= 90) &#123; System.out.println(\"A+ 입니다.\"); &#125; else if (score &gt;= 80) &#123; System.out.println(\"B+ 입니다.\"); &#125; else if (score &gt;= 70) &#123; System.out.println(\"C+ 입니다.\"); &#125; else if (score &gt;= 60) &#123; System.out.println(\"D+ 입니다.\"); &#125; else &#123; System.out.println(\"F 입니다.\"); &#125;&#125; 문자열과 정수형을 각각 조건문을 이용해 활용123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; String a = \"Man\"; int b = 0; // 자바는 String을 비교할때 equal()을 이용한다. // 이유? String은 다른 자료형들과는 다른 문자열 자료형이기 때문이다. if (a.equals(\"Man\")) &#123; System.out.println(\"남자입니다.\"); &#125; else &#123; System.out.println(\"남자가 아닙니다.\"); &#125; if (b == 3) &#123; System.out.println(\"b는 3입니다.\"); &#125; else &#123; System.out.println(\"b는 3이 아닙니다.\"); &#125; if (a.equalsIgnoreCase(\"man\") &amp;&amp; b == 0) &#123; // 대소문자 구분을 하지 않고 비교 // a가 대소문자와 상관없이 man 인지 비교하고 // b가 0 이라면, 즉 둘다 참이라면 아래의 내용이 출력된다. System.out.println(\"참입니다.\"); &#125; else &#123; System.out.println(\"거짓입니다.\"); &#125; // ==&gt; 위와 같이 연산자는 조건문 / 반복문과 함께 사용된다.&#125; while을 이용하여 1부터 1000까지의 합을 출력하는 프로그램12345678public static void main(String[] args) &#123; int i = 1, sum = 0; // 한번에 두개의 변수 선언 while (i &lt;= 1000) &#123; // 1부터 1000이 될때까지 sum += i++; &#125; System.out.println(\"1부터 1000까지의 합 : \" + sum);&#125; for문을 이용하여 삼각형을 출력하는 프로그램for문 사용11234567891011final static int N = 30; // N이라는 30이라는 값을 가진 상수를 정의public static void main(String[] args) &#123; // for문 : 초기화 부분, 조건 부분, 연산 부분 for (int i = N; i &gt; 0; i--) &#123; // int 는 N부터 시작해서 // i가 0보다 클때 // i를 1씩 감소하며 // 반복힌다. System.out.println(\"*\"); &#125; for문 사용2(이중for문)1234567891011121314151617final static int N = 30; // N이라는 30이라는 값을 가진 상수를 정의public static void main(String[] args) &#123; // for문 : 초기화 부분, 조건 부분, 연산 부분 for (int i = N; i &gt; 0; i--) &#123; // int 는 N부터 시작해서 // i가 0보다 클때 // i를 1씩 감소하며 // 반복힌다. // 이중 for문 for (int j = i; j&gt;0;j--) &#123; System.out.print(\"*\"); &#125; System.out.println( ); &#125;&#125; for문을 이용하여 원을 출력하는 프로그램1234567891011121314final static int N = 15; // N이라는 15이라는 값을 가진 상수를 정의public static void main(String[] args) &#123; for (int i = -N; i &lt;= N; i++) &#123; for (int j =- N; j &lt;= N; j++) &#123; if (i * i + j * j &lt;= N * N) &#123; System.out.print(\"*\"); &#125; else &#123; System.out.print(\" \"); &#125; &#125; System.out.println(); &#125;&#125;","link":"/2018/04/21/java-기초-조건문-반복문/"},{"title":"[java]기초 - 인터페이스(Interface)","text":"인터페이스 (Interface) - 설계의 본질 인터페이스(Interface)는 얼핏 보기에는 추상(Abstract) 클래스와 매우 흡사한 개념으로 느껴질 수 있다.인터페이스는 숙련된 자바 개발자들에게 아주 선호되는 설계 기능이면서 자바에서 다중 상속을 구현하게 해주는 고급 기술이다.추상클래스는 추상 메소드 외에 맴버 변수나 일반 메소드를 가질 수 있지만인터페이스에서는 반드시 사전에 정의된 추상 메소드와 상수만을 가질 수 있다는 특징이 있다. 인터페이스는 팀 프로젝트의 동시 작업에 유리하고 일반적으로 추상보다 요구되는 설계의 기준이 높아서 더 체계적이라고 평한다. 기본적으로 자바에서는 다중상속 구현이 불가하다. 즉 하나의 클래스가 여러개의 클래스에서 상속을 받는것이 불가하다.하지만 인터페이스를 사용하면 다중상속 구현이 가능하다. 인터페이스는 설계만 하는 것이다. 인터페이스는 추상클래스보다 더 엄격한 설계 인터페이스를 선언하고 메소드를 다루어본다.Dog.java 1234567891011public interface Dog &#123; abstract void crying(); public void show() &#123; // 오류가 발생한다. // 인터페이스는 미리 일반 메서드를 가지는 것을 막아놓았다. // 즉 인터페이스 안에서는 설계만 가능하다. // 아래와 같이 실질적인 코드를 작성하면 오류가 발생한다. System.out.println(\"Hello\"); &#125;&#125; 하지만 위의 클래스를 추상클래스로 바꾸어주면 오류가 발생하지 않는다. 1234567891011abstract class Dog &#123; abstract void crying(); public void show() &#123; // 오류가 발생한다. // 인터페이스는 미리 일반 메서드를 가지는 것을 막아놓았다. // 즉 인터페이스 안에서는 설계만 가능하다. // 아래와 같이 실질적인 코드를 작성하면 오류가 발생한다. System.out.println(\"Hello\"); &#125;&#125; 따라서 인터페이스를 사용하려면 아래와 같이 어떤 함수가 존재하는지만 알려줘야한다.즉, 설계만 가능하다. Dog.java12345public interface Dog &#123; abstract void crying(); public void show();&#125; Main.java 1234567891011121314151617181920public class Main implements Dog &#123; // 인터페이스는 implements를 사용 public static void main(String[] args) &#123; Main main = new Main(); main.crying(); main.show(); &#125; @Override public void crying() &#123; System.out.println(\"멍멍\"); &#125; @Override public void show() &#123; System.out.println(\"강아지가 짖는다.\"); &#125;&#125; 인터페이스의 다중 상속에 대하여 학습한다.Dog.java1234abstract class Dog &#123; abstract void crying();&#125; Cat.java 1234abstract class Cat &#123; abstract void crying();&#125; 아래와 같이 Dog와 Cat을 둘다 상속받으려고 하면 오류가 발생한다.==&gt;다중상속 불가 Main.java 123456789101112public class Main extends Dog, Cat &#123; public static void main(String[] args) &#123; Main main = new Main(); main.crying(); &#125; @Override public void crying() &#123; System.out.println(\"멍멍\"); &#125;&#125; 인터페이스를 사용하여 다중상속을 구현해 본다. Dog.java123public interface Dog &#123; abstract void crying();&#125; Cat.java 123public interface Cat &#123; abstract void crying();&#125; 아래와 같이 인터페이스를 사용하면 Dog와 Cat을 둘다 상속 받더라도오류가 발생하지 않는다. Main.java12345678910111213public class Main implements Dog, Cat &#123; public static void main(String[] args) &#123; Main main = new Main(); main.crying(); &#125; @Override public void crying() &#123; System.out.println(\"멍멍\"); &#125;&#125; ※ 설계된 모든 메서드들을 다 구현해야 한다. 하나라도 구현하지 않으면 오류가 발생한다.","link":"/2018/05/03/java-기초-인터페이스-Interface/"},{"title":"[java] 데이터 출력","text":"자바의 입출력 데이터 출력 - int 값 출력123456789101112public static void main(String[] args) throws Exception &#123; FileOutputStream out = new FileOutputStream(\"temp/test3.data\"); int money = 1_3456_7890; // = 0x080557d2 out.write(money); //항상 출력할 때는 맨 끝 1바이트만 출력한다. out.close(); System.out.println(\"데이터 출력 완료!\");&#125; 데이터 출력 - int 값 읽기1234567891011public static void main(String[] args) throws Exception &#123; FileInputStream in = new FileInputStream(\"temp/test3.data\"); // Exam02_1을 실행하여 출력한 데이터를 read()로 읽는다. // read()는 1바이트를 읽어 int 값으로 만든 후 리턴한다. int value = in.read(); // 실제 리턴한 값은 0x08이다. in.close(); System.out.printf(\"%x\\n\", value);&#125;","link":"/2018/04/11/java-데이터-출력/"},{"title":"[java]용어정리","text":"용어 의미 컴파일(compile) 문자 집합(Character Set) 인코딩(Encoding) 비트(Bit) = 바이너리 바이트코드(bytecode) 클래스(class) 패키지(package) 애노테이션(annotation) 리터럴(literal) 데이터 타입(data type) == 데이터 형식 == 자료형","link":"/2018/05/05/java-용어정리/"},{"title":"[java] 기초 - 변수(Variable)","text":"변수의 설정 및 사용방법 변수(Variable)와 상수(Constant)변수: 변할수 있는 수 (열린 상자)상수: 항상 변하지 않는 수 (닫힌 상자) 변수는 그 내부에 있는 값을 프로그램이 실행되는 도중에 언제든지 교체할 수 있다.상수는 한 번 설정되면 프로그램이 종료될 때까지 변경되지 않는 데이터이다. 변수의 쓰임12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; // 변수를 선언하고 그 안에 값을 넣는 초기화를 한다. int intType = 100; // 변수를 선언하는 부분 // 정수형을 나타내는 int 변수의 이름을 intType으로 만들고 // intType이라는 변수안에 100 이란 값을 넣었다(저장한다). double doubleType = 150.5; // 변수를 선언하는 부분 // 실수형을 나타내는 double 변수의 이름을 doubleType으로 만들고 // doubleType이라는 변수안에 150.5 라는 값을 넣었다(저장한다). String stringType = \"문자열\"; // 변수를 선언하는 부분 // 문자열을 나타내는 String 변수의 이름을 stringType으로 만들고 // stringType이라는 변수안에 \"문자열\" 이라는 값을 넣었다(저장한다). // 각각의 변수를 출력한다. System.out.println(intType); // 괄호안에 들어있는 변수를 출력하고 한칸 줄바꿈을 한다. System.out.println(doubleType); // 괄호안에 들어있는 변수를 출력하고 한칸 줄바꿈을 한다. System.out.println(stringType); // 괄호안에 들어있는 변수를 출력하고 한칸 줄바꿈을 한다.&#125; 상수의 쓰임12345678910111213141516171819final static double PI = 3.141592; // 상수의 선언 // 메인함수 밖에 선언된다. // final = 한번 선언되면 절대로 변하지 않는다. 바뀔 수 없다는 의미 // ==&gt;즉 상수의 의미 // PI라는 이름으로 상수를 정의하고 // 3.141592라는 값을 넣었다(저장한다). // 상수는 절대 바뀔 수 없는 값이기 때문에 final이라는 문법을 사용한다.public static void main(String[] args) &#123; int r = 30; // 변수의 선언 // 정수형을 나타내는 int 변수의 이름을 r으로 만들고 // r이라는 변수안에 30 이란 값을 넣었다(저장한다). // 변수를 출력한다 System.out.println(r * r * PI); // 원의 넓이를 구하는 공식 // 반지름(r)이 30인 원의 넓이&#125; 표현가능범위표현 123456789101112131415final static int INT_MAX = 2147483647; // 상수의 선언 // INT_MAX라는 이름으로 정수형 상수를 정의하고public static void main(String[] args) &#123; int a = INT_MAX; // 위에서 만들었던 INT_MAX라는 상수를 // a라는 변수안에 값으로 넣어준다. // 출력 System.out.println(a); // 정상출력 System.out.println(a + 1); //비정상출력(값의 오류) &#125; 자료형의 종류와 구분 (Prinitive Data Type) 자료형 데이터 크기 (btye) 크기 (bit) 표현가능범위 boolean 참과 거짓 1 byte 1 bit true, false char 문자 2 byte 16 bits Unicode Character byte 정수 1 byte 8 bits -128 ~ 127 short 정수 2 byte 16 bits -32,768 ~ 32,767 int 정수 4 byte 32 bits -2,147,483,648 ~ 2,147,483,647 long 정수 8 byte 64 bits -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 float 실수 4 byte 32 bits ±(1.40129846432481707e-45 ~ 3.40282346638528860e+38) double 실수 8 byte 64 bits ±(4.94065645841246544e-324d ~ 1.79769313486231570e+308d) 사칙연산 프로그램123456789101112131415public static void main(String[] args) &#123; // a 와 b 변수를 선언하고 값을 넣어준다.(초기화) int a = 1; int b = 2; // 사칙연산 출력 // 문자열과 정수형 형태를 합쳐서 식을 표현할 수 있다. System.out.println(\"a + b = \" + (a + b)); System.out.println(\"a - b = \" + (a - b)); System.out.println(\"a * b = \" + (a * b)); System.out.println(\"a / b = \" + (a / b)); &#125; 형변환(실수형 -&gt; 정수형)1234567891011int a1 = 0.5; // a1 라는 값은 int로 선언되었기 때문에 정수만 들어갈 수 있다. // ==&gt; 오류가 발생한다. 0.5라는 실수는 넣을 수 없다.// 해결방법int a2 = (int) 0.5; // 형변환을 한다. // ==&gt; 즉 실수형을 정수형으로 형변환한다.// 출력System.out.println(a2); // 출력결과 0 // ==&gt; 실수형을 정수형으로 바꿀 때에는 // ==&gt; 소수점 자리 뒷 부분은 전부 제거된다. 형변환(정수형 -&gt; 실수형)12345678910public static void main(String[] args) &#123; double b = 0.5; int a = (int) (b + 0.5); // b 가 어떠한 실수 값이던 간에 // 항상 0.5를 더하고 int 형으로 변경한다. // ==&gt; 항상 반올림이 된 값만 출력한다. // 출력 System.out.println(a); // 결과 1&#125; 변수활용의 주의사항 자바에서는 변수 초기화를 하지 않으면 사용할 수 없다. 정수를 나타내는 타입 [btye, short, int, long] 정부 변수안에 실수를 넣으면 정수 부분만 변수에 저장된다. 실수 값을 반올림할 때는 변수에 0.5를 더한 뒤에 정수형으로 형변환을 하면 된다. 반올림한 값 =(int)(실수 + 0.5);","link":"/2018/04/21/java기초-변수-Variable/"},{"title":"[javascript & jquery] - chapter01 변수_part02","text":"Lesson04 변수의 값 저장 및 변경변수 값 저장변수에는 상수뿐 아니라 또 다른 변수 자체를 저장할 수 있다. 123[문법]var 변수A = 데이터; // 데이터가 변수A에 저장된다.var 변수B = 변수A; // *변수B에 변수A에 들어있는 값이 복사돼 저장 변수 data1을 만든 후 숫자 데이터 1234를 저장, 변수 data2를 만든 후 data1의 값을 저장12var data1 = 1234;var data2 = data1; 변수 값 변경var을 붙이지 않은 상태에서 변수에 값을 대입해주면 변수의 값이 변경된다. 1234[문법]var 변수이름 = 데이터;변수이름 = 신규 데이터1;변수이름 = 신규 데이터2; 변수 data1을 만든 후 초깃값을 10으로 한 후, 데이터를 다시 20으로 또 다시 한번 30으로 변경123var data1 = 10;data1 = 20; data1 = 30; Lesson05 변수의 값이 자동으로 읽혀지는 경우 우측에 변수를 두는 경우 함수 호출 시 변수를 매개변수(파라미터) 값으로 사용하는 경우 연산자와 함께 사용하는 경우 우측에 변수를 두는 경우(변수에 들어있는 값이 읽혀 다른 변수에 대입하는 경우)12[문법]변수A = 변수B(우측에 있을 때) 우측에 변수를 두면 변수 자체가 넘어가는 것이 아니라 변수 안에 들어 있는 데이터가 복사되어 좌측 변수에 저장된다. 정확히는 변수 안에 들어 있는 데이터 중 숫자, 문자, 논리 데이터만이 복사되며 배열, 함수, 객체 데이터 등은 실제 데이터가 들어있는 주소가 복사된다. 아래의 구문을 해석하기12var name =\"java\"var temp = name; name 변수에 들어있는 “java”라는 값이 복사 되어 temp 변수에 대입된다. 함수 호출 시 변수를 매개변수 값으로 사용하는 경우12[문법]함수(변수); 함수 호출과 함께 변수를 사용하는 경우에도 값이 복사되어 매개변수(파라미터)로 넘어 간다. 아래의 구문을 해석하기123456function test1(userName)&#123; alert(\"userName =\" + userName);&#125;var name = \"java\";test1(name); test1(name); 을 호출하면 test1(“java”)로 변경된다.","link":"/2018/05/29/javascript-jquery-chapter01-변수-part02/"},{"title":"[javascript&jquery] 프로그래밍의 기초","text":"스크립트란 무엇이며 어떻게 만들 수 있는가?스크립트는 명령어의 모음이다. 스크립트는 컴퓨터가 단계별로 따라 할 수 있는 명령어들로 구성된다.브라우저는 사용자가 웹페이지와 어떻게 상호작용하느냐에 따라 스크립트에서 필요한 부분만을 사용한다.스크립트는 주변 상황에 따라 코드의 서로 다른 부분을 실행할 수 있다. 스크립트란 무엇이며 어떻게 작성할 수 있는가? 스크립트는 컴퓨터가 목표한 바를 달성하기 위해 실행해야 하는 명령의 집합이다. 스크립트는 실행될 때마다 전체 명령의 일부를 실행하며, 실행되는 명령은 매번 다를 수 있다. 명령들은 컴퓨터가 작업을 프로그래밍적으로 해결할 수 있도록 구성되어야 한다. 스크립트를 작성하려면 목표를 세부적인 단계로 나눈 후 각 단계를 완료하기 위한 작업들을 정의해야 한다.(이때 흐름도를 작성하는 것이 큰 도움이 된다.) 객체와 속성객체컴퓨터 프로그래밍에서 실제 세계에 존재하는 각각의 물리적인 물체들은 객체(object)로 표현된다. 각각의 객체는 아래의 정보를 결합되어 객체를 표현허는 모델을 구성한다. 속성(properties) 이벤트(events) 메서드(methods) 속성(특징)각 속성은 이름(name)과 값(value)로 구성되며, 이름과 값은 객체의 개별 인스턴스가 정확히 어떤 것인지를 표현하는데 사용된다.","link":"/2018/05/28/javascript-jquery-프로그래밍의-기초'/"},{"title":"[java] 기초 - 연산자(Operator)","text":"연산자 : 연산을 도와주는 문법 계산의 기본 연산자 참고사항 i++ 와 ++i 는 단순히 값을 증가시키려는 목적이라면 그 기능이 동일하다. 100 &lt; x &lt; 200은 잘못된 표현이다. ==&gt; (100 &lt; x) &amp;&amp; (x &lt; 200)로 표현하는것이 올바른 연산식 표현이다. i++ 은 i+ 와 동일한 표현이다. 또한, i= i + 1 과도 동일한 표현이다.==&gt;모두 1만큼 증가시킨다는 의미를 나타낸다. ## 초를 입력 받아 몇 분 몇 초인지 계산하는 프로그램12345678910111213final static int SECOND = 1000; // 상수 선언 // SECOND 상수에 1000을 넣는다(저장한다).public static void main(String[] args) &#123; int minute = SECOND / 60; // 상수 1000초는 몇분 int second = SECOND % 60; // 상수 1000초는 몇초 System.out.println(minute + \"분\" + second + \"초\"); // 출력 16분 40초&#125; ++와 –연산(증감연산자)12345678910public static void main(String[] args) &#123; int a = 10; System.out.println(\"현재 a의 값 = \" + a ); a++; System.out.println(\"현재 a의 값 = \" + a ); System.out.println(\"현재 a의 값 = \" + ++a ); // 먼저 a에 1을 더하여 출력 System.out.println(\"현재 a의 값 = \" + a++ ); // 값의 변화가 없다. // 출력이 된 이후에 값이 변한다. System.out.println(\"현재 a의 값 = \" + a ); // 출력 결과 13&#125; ++와 –연산2(증감연산자)1234567891011public static void main(String[] args) &#123; int i = 20; System.out.println(i); i++; System.out.println(i); i = i + 1; // 아래의 식과 동일한 의미 ==&gt; 1이 증가한다. System.out.println(i); i += 1; // 위의 식과 동일한 의미 ==&gt; 1이 증가한다. System.out.println(i);&#125; %연산자(모듈러 연산자)1234567891011121314151617public static void main(String[] args) &#123; // 모듈러 연산자를 이용하여 나머지를 구한다. System.out.println(1 % 3); System.out.println(2 % 3); System.out.println(3 % 3); System.out.println(4 % 3); System.out.println(5 % 3); System.out.println(6 % 3); //출력결과 // 1 // 2 // 0 // 1 // 2 // 0&#125; ==, &gt;, &lt;, &amp;&amp;, ||, ! 연산123456789public static void main(String[] args) &#123; int a = 50; int b = 50; System.out.println(\"a와 b가 같은가? \" + (a == b)); System.out.println(\"a와 b가 큰가? \" + (a &gt; b)); System.out.println(\"a와 b가 작은가? \" + (a &lt; b)); System.out.println(\"a와 b가 같으면서 a가 b보다 큰가? \" + ((a == b) &amp;&amp; (a &gt; b))); System.out.println(\"a가 50이 아닌가? \" + !(a == 50));&#125; 조건 ? 참 : 거짓(삼항연산자)12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; int x = 50; int y = 60; System.out.println(\"최대값 \" + max(x, y) );&#125;// 반환형, 함수이름, 매개변수static int max(int a, int b) &#123; int result = (a &gt; b) ? a : b; return result; // int a와 int b를 입력받아서 // 둘 중 더 큰값을 반환하는 max라는 함수 // 둘 중 더 큰값을 int 형태로 반환한다. // int result 는 a가 보다 클 때 // 식이 참값이라면 a를 반환하고 // 거짓이라면 b를 반환한다. // 그리고 그 결과인 result를 반환한다. // 출력결과 최대값 60 &#125; pow()를 이용한 거듭제곱 연산12345public static void main(String[] args) &#123; double a = Math.pow(3.0, 20.0); // 3의 20제곱이 실수 a에 넣는다. System.out.println(\"3의 20제곱은 \" + (int) a);&#125;","link":"/2018/04/21/java기초-연산자-Operator/"},{"title":"[java] 기초 - 자료형(Data Type)","text":"자료형 : 나에게 필요한 데이터 타입 어떠한 데이터를 표현하고 싶을 때,데이터를 표현해줄 수 있는 타입을 만들어준다. =&gt; 표현할 데이터의 형태를 정의 자료형(Data Type) Primitive (원시자료형) Non-Primitive (비원시자료형) =&gt; 내부적 함수가 존재한다. 일반적인 프로그래밍 언어에는 정수 자료형 int , 실수 자료형 float과 double, 문자 자료형 char, 문자 자료형 char, 문자열 자료형 String이 사용된다. 자바에서는 특히 String을 많이 활용한다. double을 이용한 평균값 구하는 프로그램12345678910public static void main(String[] args) &#123; double a = 10.3; double b = 9.6; double c = 10.1; System.out.println((a + b + c) / 3); // 3개의 실수형을 선언해서 3개의 값을 더하고 // 3으로 나눈 즉, 평균값을 구하는 프로그램&#125; char을 이용한 문자출력 프로그램12345678public static void main(String[] args) &#123; for (char i = 'a'; i &lt;= 'z'; i++) &#123; System.out.print(i + \" \"); // 컴퓨터 내부적으로 아스키코드를 활용하여 // a 부터 z 까지 1씩 증가시키면서 출력한다. &#125;&#125; 10진수를 8진수와 16진수로 변경하는 프로그램123456789public static void main(String[] args) &#123; int a = 200; System.out.println(\"10진수: \" + a); System.out.format(\"8진수: %o\\n\", a); // 형식지정자 System.out.format(\"16진수: %x\\n\", a); // 형식지정자 // 10진수를 8진수와 16진수로 변경&#125; String의 substring 함수 활용1234567891011public static void main(String[] args) &#123; String name = \"String Type\"; System.out.println(name); System.out.println(name.substring(0, 1)); // 실행결과 S // 0 =&gt; 출력할 첫번째문자열 (시작점) // 1 =&gt; 출력할 마지막 문자열 (종료점) System.out.println(name.substring(5, 8)); // 실행결과 g T // 공백도 하나의 문자로 인식 &#125; 자료형 정리 기본적으로 정수를 나타내는 자료형이 많은 이유는 각 자료형이 차지하는 메모리 공간의 크기가 다르기 때문 double 형이라고 하더라도 과도하게 큰 수를 저장하고자 하면 잘못된 계산결과가 나올 수 있다. 소수점 표기 형식을 지수형식으로 출력하고 싶으면 %e를 이용하면 된다. 자바에서 String은 내부적으로 Char의 배열로 되어있다. 자바에서 String의 최대 크기는? 컴퓨터의 메모리 크기만큼 자바의 String은 클래스 기반의 비원시적인 자료형","link":"/2018/04/21/java기초-자료형-DataType/"},{"title":"[자바스크립트]","text":"test","link":"/2018/10/08/자바스크립트/"},{"title":"[new]","text":"","link":"/2018/10/12/new/"},{"title":"[spring] chapter02 - 스프링에 대한 간단 소개","text":"스프링이 인기를 얻게 된 이유는 무엇인가? 스프링의 중요한 특징들은 무엇인가? 스프링 프레임워크가 개발의 대세가 된 이유프레임워크 = ‘뼈대나 근간’을 이루는 코드들의 묶음 중요한 점은 이 뼈대가 왜 필요한지 프레임워크의 최대 장점은 개발에 필요한 도구를 이미 코드로 만들어 놓았기 때문에, 실력이 부족한 개발자라 하더라도반쯤 완성한 상태에서 필요한 부분을 조립하는 형태의 개발이 가능하다는 점. 사용자 장점 회사 프레임워크를 사용하면 일정한 품질이 보장되는 결과물을 얻는다. 개발자 완성된 구조에 자신이 맡은 코드를 개발해서 넣어주는 형태이브로 개발 시간 단축. 스프링 프레임워크는 가장 성공적인 ‘경랑(light-weight) 프레임워크이다.’ 경량프레임워크란?경량프레임워크라는 용어는 90년대 말에 복잡한 구동 환경과 하드웨어적인 구성이 필요한 프레임워크의 반대되는 개념으로 등장특정 기능을 위주로 간단한 jar 파일 등을 이용해서 모든 개발이 가능하도록 구성된 프레임워크를 의미한다. 그 당시에 나왔던 다른 프레임워크들과 다르게 스프링은 아래와 같은 뚜렷한 차별성을 가지고 있었다. 복잡함에 반기를 들어서 만들어진 프레임워크 스프링은 그 태생 자체가 엔터프라이즈급의 시스템이 실패하는 이유를 복잡성으로 보고, 복잡성을 해결하기 위해 나온 경량화된 프레임워크.일반적인 Java의 클래스와 인터페이스를 이용하는 구조를 사용하기 때문에 진입 장벽이 높지 않았고, EJB에 비해 가볍기 때문에 빠른 시간에엔터프라이즈급의 시스템을 작성할 수 있다. 프로젝트의 전체 구조를 설계할 때 유용한 프레임워크 다른 프레임워크들은 웹 영역이나 데이터베이스 영역 등의 전문적인 영역에 대해서만 지원하는 경우가 많았고, 비지니스 로직을 처리하는 부분에 대한 설계는 개발자의 역량에 맡기는 경우가 많았다.반면에 스프링은 어느 한 분야에 집중하지 않고, 전체를 설계하는 용도로 사용될 수 있었다. ==&gt; 제어의 역행(IoC) 다른 프레임워크들의 포용 스프링은 전체 구조에 집중했기 때문에 특정한 영역의 프레임워크와 공존하는 방식으로 사용할 수 있었다.다른 프레임워크들은 특정 프레임워크를 채택하면 해당 영역 전체를 수정해야 하는 고질적인 문제를 가지고 있었지만, 스프링은 다른 프레임워크들과의 통합을 지원했기 때문에최소한의 수정이 가능했다.스프링의 최대 장점은 기본 뼈대를 흔들지 않고 여러 종류의 프레임워크를 혼용해서 사용할 수 있다는 점. 개발 생산성과 개발 도구의 지원 스프링의 경우 이론적으로는 개발자가 제대호 이해해야 하는 부분이 많지만, 결과적으로 코딩의 양은 확실히 줄어들 수 있었고, 유지보수에 있어서도 XML의 설정 등을 이용했기 때문에환영받을 수 있었다. STS나 Eclipse, Intellij 등의 플러그인의 지원 역시 다른 프레임워크들에 비해서 빠른 업데이트가 되었기 때문에 별도의 새로운 개발 도구에 대한 적응 없이도 개발이 가능했다. 스프링의 주요 특징 POJO 기반의 구성 의존성 주입(DI)을 통한 객체 간의 관계 구성 AOP(Aspect-Oriented-Programming) 지원 편리한 MVC 구조 WAS에 종속적이지 않은 개발 환경 POJO 기반의 구성","link":"/2018/05/05/spring-chapter02-스프링에-대한-간단-소개/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"spring","slug":"spring","link":"/tags/spring/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"spring","slug":"spring","link":"/categories/spring/"}]}